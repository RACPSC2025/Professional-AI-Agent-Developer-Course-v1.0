# <img src="../imagenes/tool-design-icon.png" width="30" height="30" style="vertical-align:middle"> Module 4: AI Agent Design Patterns (English)
## <span style="color:#00a14b">Lesson 4.1: Tool Use Design Pattern</span>

### Introduction to the Tool Use Pattern

The tool use pattern is fundamental to modern AI agent architectures. This pattern enables agents to extend their capabilities beyond their internal knowledge by interacting with external systems such as databases, APIs, files, and other business systems.

### What is a Tool in AI Agent Context?

A tool in the context of AI agents is any function, service, or external system that an agent can invoke to complete a task. Tools enable agents to:

1. **Access real-time data** that is not in their trained knowledge
2. **Perform actions on external systems** such as updating databases or sending emails
3. **Perform complex calculations** that require specialized software
4. **Interact with the physical environment** through smart devices
5. **Integrate with business systems** such as ERPs, CRMs, and other business systems

### Components of the Tool Use Pattern

1. **Main Agent**: The component that decides which tools to use and when to use them
2. **Tool Catalog**: Collection of available tools with metadata
3. **Invocation System**: Mechanism for calling tools securely
4. **Result Processor**: Component that interprets and utilizes tool results
5. **Security Middleware**: Layer that controls access and applies security policies

### Tool Implementation in Microsoft Framework (MAF)

#### Native Tool Definition

```python
from maf.tools import Tool, tool
from typing import Dict, Any
import requests
import json

class BusinessTools:
    """Collection of business tools for AI agents"""
    
    @tool
    def get_sales_data(self, period: str, region: str = "all") -> Dict[str, Any]:
        """
        Gets sales data for a specific period and region.
        
        Args:
            period: Time period (e.g., "last_month", "last_quarter", "year_to_date")
            region: Specific region (optional, defaults to "all")
            
        Returns:
            Dict with sales data, key metrics, and trends
        """
        # Simulation of call to business system
        url = f"https://api.company.com/sales?period={period}&region={region}"
        headers = {"Authorization": "Bearer YOUR_TOKEN"}
        
        try:
            response = requests.get(url, headers=headers)
            if response.status_code == 200:
                sales_data = response.json()
                return {
                    "period": period,
                    "region": region,
                    "total_revenue": sales_data.get("total_revenue"),
                    "units_sold": sales_data.get("units_sold"),
                    "growth_rate": sales_data.get("growth_rate"),
                    "top_products": sales_data.get("top_products", [])[:5]
                }
            else:
                return {"error": f"Error getting sales data: {response.status_code}"}
        except Exception as e:
            return {"error": f"Error calling tool: {str(e)}"}
    
    @tool
    def update_customer_record(self, customer_id: str, field: str, new_value: str) -> str:
        """
        Updates a specific field in a customer record.
        
        Args:
            customer_id: Unique customer ID
            field: Field to update (e.g., "email", "address", "phone")
            new_value: New value for the field
            
        Returns:
            Confirmation message or error
        """
        # Validate allowed field
        allowed_fields = ["email", "address", "phone", "preferences"]
        if field not in allowed_fields:
            return f"Not allowed field. Valid fields: {allowed_fields}"
        
        # Simulation of update in business system
        url = f"https://api.company.com/customers/{customer_id}"
        headers = {"Authorization": "Bearer YOUR_TOKEN", "Content-Type": "application/json"}
        payload = {field: new_value}
        
        try:
            response = requests.put(url, headers=headers, json=payload)
            if response.status_code == 200:
                return f"Customer record {customer_id} updated successfully. Field: {field}, Value: {new_value}"
            else:
                return f"Error updating customer record: {response.status_code}"
        except Exception as e:
            return f"Error updating customer record: {str(e)}"
    
    @tool
    def schedule_appointment(self, customer_id: str, service_type: str, preferred_time: str, consultant: str = None) -> Dict[str, Any]:
        """
        Schedules an appointment for a customer with a specific service type.
        
        Args:
            customer_id: Customer ID
            service_type: Service type (e.g., "consultation", "demo", "support")
            preferred_time: Preferred date and time in ISO 8601 format
            consultant: Preferred consultant (optional)
            
        Returns:
            Dict with scheduled appointment details
        """
        # Appointment scheduling simulation
        import uuid
        appointment_id = f"APT-{str(uuid.uuid4())[:8].upper()}"
        
        appointment_data = {
            "appointment_id": appointment_id,
            "customer_id": customer_id,
            "service_type": service_type,
            "scheduled_time": preferred_time,
            "consultant": consultant if consultant else "auto_assigned",
            "status": "confirmed",
            "confirmation_sent": False
        }
        
        # The real scheduling logic would go here
        # Including availability validation, confirmation sending, etc.
        
        return {
            "appointment_id": appointment_id,
            "status": "scheduled_simulation",  # No real scheduling in demo
            "details": appointment_data,
            "message": "Appointment scheduled in simulation. In a real system, this operation would be subject to availability validation and confirmation sending."
        }

# Instantiate tools
business_tools = BusinessTools()
```

#### Semantic Tools (Prompt-Based)

In addition to native code tools, MAF also supports semantic tools based on prompts:

```python
from maf.tools import SemanticTool

# Example of semantic tool (conceptual)
semantic_sales_tool = SemanticTool(
    name="sales_insight_analyzer",
    description="Analyzes sales data and provides strategic insights",
    prompt_template="""
    Based on the following sales data for {period}:
    {sales_data}
    
    Provide an analysis including:
    1. Key trends identified
    2. Opportunity areas
    3. Strategic recommendations
    4. Comparative metrics
    """
)
```

### MCP (Model Context Protocol) Integration with Tools

The Model Context Protocol (MCP) provides a standardized layer for tool integration that enables agents to discover and use tools in a secure and standardized way.

```python
# Example of MCP integration with business tools
from maf.mcp import MCPConnector
from maf.tools import MCPToolAdapter

class MCPBusinessTools:
    """MCP integration for business tools"""
    
    def __init__(self):
        self.mcp_connector = MCPConnector(server_url="https://mcp.enterprise.com")
    
    def create_tools_from_mcp_services(self):
        """Creates tools automatically from available MCP services"""
        available_services = self.mcp_connector.list_available_services()
        
        tools = []
        for service in available_services:
            tool_adapter = MCPToolAdapter(
                service_name=service.name,
                service_endpoint=service.endpoint,
                service_schema=service.input_schema
            )
            tools.append(tool_adapter)
        
        return tools
```

### Tool Integration Patterns

#### 1. Dynamic Discovery Pattern

Agents can discover available tools at runtime:

```python
class ToolDiscoverer:
    """System for dynamically discovering available tools"""
    
    def __init__(self, tool_catalog):
        self.tool_catalog = tool_catalog
    
    def discover_relevant_tools(self, task_description: str) -> list:
        """Discovers tools relevant to a specific task"""
        # Analyze task description to identify keywords
        keywords = self._extract_keywords(task_description)
        
        # Filter tools based on keywords
        relevant_tools = []
        for tool in self.tool_catalog:
            if any(keyword in tool.description.lower() for keyword in keywords):
                relevant_tools.append(tool)
        
        return relevant_tools
    
    def _extract_keywords(self, text: str) -> list:
        """Extracts keywords from text"""
        # Simplified for the example
        keywords = ["sales", "customer", "appointment", "data", "report", "update"]
        found_keywords = [kw for kw in keywords if kw in text.lower()]
        return found_keywords
```

#### 2. Sequential Invocation Pattern

For tasks requiring a series of tool calls in a specific order:

```python
class SequentialToolInvoker:
    """Invokes tools in a specific sequence"""
    
    def __init__(self, tool_registry):
        self.tool_registry = tool_registry
    
    async def execute_sequential_workflow(self, tool_sequence: list, initial_params: dict = None):
        """Executes a sequence of tools passing results from one to another"""
        params = initial_params or {}
        results = []
        
        for tool_spec in tool_sequence:
            tool_name = tool_spec["tool_name"]
            tool_params = tool_spec.get("params", {})
            
            # Merge parameters passed with those defined in sequence
            merged_params = {**params, **tool_params}
            
            # Invoke tool
            tool = self.tool_registry.get_tool(tool_name)
            result = await tool.invoke(merged_params)
            
            # Save result
            results.append({
                "tool_name": tool_name,
                "input": merged_params,
                "output": result
            })
            
            # Update parameters for next tool
            params.update(result)
        
        return results
```

#### 3. Parallel Invocation Pattern

For tasks that can benefit from parallel tool execution:

```python
import asyncio

class ParallelToolInvoker:
    """Invokes multiple tools in parallel"""
    
    def __init__(self, tool_registry):
        self.tool_registry = tool_registry
    
    async def execute_parallel_tools(self, tool_specs: list):
        """Executes multiple tools in parallel"""
        async def invoke_tool(tool_spec):
            tool_name = tool_spec["tool_name"]
            params = tool_spec.get("params", {})
            
            tool = self.tool_registry.get_tool(tool_name)
            result = await tool.invoke(params)
            
            return {
                "tool_name": tool_name,
                "input": params,
                "output": result
            }
        
        # Execute all tools in parallel
        tasks = [invoke_tool(spec) for spec in tool_specs]
        results = await asyncio.gather(*tasks)
        
        return results
```

### Best Practices for Tool Usage

#### 1. Security and Input Validation

Always validate inputs before passing them to external tools:

```python
import re

def validate_tool_inputs(params: dict, expected_types: dict, allowed_values: dict = None):
    """Validates tool inputs for security"""
    for param_name, expected_type in expected_types.items():
        if param_name in params:
            value = params[param_name]
            
            # Verify type
            if not isinstance(value, expected_type):
                raise ValueError(f"Parameter {param_name} must be of type {expected_type.__name__}")
            
            # Validate format if string
            if expected_type == str:
                # Prevent command or SQL injection
                if re.search(r'[;\'"\\]', value):
                    raise ValueError(f"Parameter {param_name} contains invalid characters")
            
            # Validate allowed values
            if allowed_values and param_name in allowed_values:
                if value not in allowed_values[param_name]:
                    raise ValueError(f"Parameter {param_name} has invalid value: {value}")
    
    return True
```

#### 2. Access Control and Authorization

Implement authorization layers for sensitive tools:

```python
from enum import Enum

class ToolAccessLevel(Enum):
    READ_ONLY = "read_only"
    READ_WRITE = "read_write"
    ADMIN = "admin"

class ToolPermissionManager:
    """Manages permissions and access to tools"""
    
    def __init__(self):
        self.tool_permissions = {
            "get_sales_data": [ToolAccessLevel.READ_ONLY, ToolAccessLevel.READ_WRITE, ToolAccessLevel.ADMIN],
            "update_customer_record": [ToolAccessLevel.READ_WRITE, ToolAccessLevel.ADMIN],
            "schedule_appointment": [ToolAccessLevel.READ_WRITE, ToolAccessLevel.ADMIN]
        }
    
    def check_access(self, agent_role: str, tool_name: str) -> bool:
        """Checks if an agent can use a specific tool"""
        if tool_name not in self.tool_permissions:
            return False
        
        required_levels = self.tool_permissions[tool_name]
        agent_level = ToolAccessLevel(agent_role.upper().replace(" ", "_"))
        
        return agent_level in required_levels
```

#### 3. Error Handling and Resilience

Implement robust error handling strategies:

```python
import time
from typing import Optional

class ToolInvokerWithResilience:
    """Tool invoker with error handling and retries"""
    
    def __init__(self, max_retries: int = 3, backoff_factor: float = 1.0):
        self.max_retries = max_retries
        self.backoff_factor = backoff_factor
    
    async def invoke_with_retry(self, tool, params: dict) -> dict:
        """Invokes tool with retry logic"""
        last_exception = None
        
        for attempt in range(self.max_retries):
            try:
                result = await tool.invoke(params)
                return result
            except Exception as e:
                last_exception = e
                
                if attempt < self.max_retries - 1:
                    # Exponential backoff before retry
                    wait_time = self.backoff_factor * (2 ** attempt)
                    await asyncio.sleep(wait_time)
                else:
                    # All retries failed
                    pass
        
        # All retries failed
        return {"error": f"All retries failed. Last error: {str(last_exception)}"}
```

### Recent Professional Examples (2025)

#### Example 1: Technical Support System at Cisco
Cisco implemented a technical support system based on agents with extensive tool usage:
- **Dynamic Discovery Pattern**: Agents that identify appropriate tools based on the problem
- **Sequential Invocation Pattern**: Automated diagnosis that calls multiple tools in order
- **Access Control**: Authorization middleware for sensitive network tools
- **Result**: 45% reduction in problem resolution time, 40% improvement in diagnostic accuracy

#### Example 2: Financial Research Platform at Bloomberg
Bloomberg developed a financial research platform with agents:
- **Parallel Invocation Pattern**: Simultaneous query to multiple financial data sources
- **Security Validation**: Input validation to prevent malicious injections
- **Tool Resilience**: Retry systems for intermittent data sources
- **Result**: Analysis time reduced from 4-6 hours to 30 minutes, over 50% improvement in accuracy

#### Example 3: HR Management System at SAP
SAP created a human resources assistant with enterprise tools:
- **MCP Integration**: Standardized connection to payroll and benefits systems
- **Input Validation**: Security control for sensitive employee data
- **Distributed Memory Pattern**: Share context between different HR tools
- **Result**: 60% faster resolution of employee queries, 50% reduction in administrative errors

#### Example 4: Content Management Platform at Adobe
Adobe implemented an AI-based content management system:
- **Tool Sequence Pattern**: Content workflow automation (ingestion, processing, publishing)
- **Access Control**: Different levels for tools based on user role
- **Security Middleware**: Content filtering and rights control
- **Result**: 150% increase in asset management efficiency, 70% improvement in copyright compliance

#### Example 5: Shipment Tracking System at UPS
UPS developed an agent-based tracking system:
- **Parallel Invocation**: Multiple query to shipment, route, and status databases
- **Error Handling**: Robust systems to handle intermittent databases
- **Discovery Pattern**: Tools that adapt to different shipment types and systems
- **Result**: 80% reduction in response time, 45% improvement in delivery estimate accuracy

### Production Considerations

#### Performance
- **Caching**: Caching of expensive tool results
- **Rate Limiting**: Control of call frequency to external tools
- **Sequence Optimization**: Minimize the number of required calls

#### Security
- **Input Validation**: Verify all parameters before using tools
- **Access Control**: Middleware to restrict access to sensitive tools
- **Auditing**: Complete logging of all tool invocations
- **Output Sanitization**: Filter sensitive results before displaying

#### Maintainability
- **Tool Documentation**: Clear specification of inputs, outputs, and purpose
- **Unit Testing**: Tests for each tool to verify functionality
- **Versioning**: Version control for tools that change over time
- **Monitoring**: Observability of errors, performance, and tool usage

### Future Trends in Tool Usage (2025-2026)

- **Auto-Generated Tools**: Agents that create their own tools as needed
- **Advanced Semantic Integration**: Tools that better understand usage context
- **Built-in Security**: Security controls integrated in tool registration
- **Anomaly Detection**: Systems that identify unusual or potentially malicious tool usage

### Next Lesson

In the next lesson, we'll explore the Agentic RAG (Retrieval-Augmented Generation) pattern, which combines information retrieval capabilities with content generation to create more intelligent and contextual agents.