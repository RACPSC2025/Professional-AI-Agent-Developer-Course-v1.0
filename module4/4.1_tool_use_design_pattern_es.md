# <img src="../imagenes/tool-design-spanish-icon.png" alt="Diseño de Herramientas" width="30" height="30" style="vertical-align:middle"> Módulo 4: Patrones de Diseño de Agentes de IA (Español)
## <span style="color:#d40078">Lección 4.1: Patrón de Diseño de Uso de Herramientas</span>

### Introducción al Patrón de Uso de Herramientas

El patrón de uso de herramientas es fundamental en las arquitecturas de agentes de IA modernos. Este patrón permite que los agentes amplíen sus capacidades más allá de su conocimiento interno al interactuar con sistemas externos como bases de datos, APIs, archivos y otros servicios empresariales.

### ¿Qué es una Herramienta en el Contexto de Agentes de IA?

Una herramienta en el contexto de agentes de IA es cualquier función, servicio o sistema externo que un agente puede invocar para completar una tarea. Las herramientas permiten a los agentes:

1. **Acceder a datos en tiempo real** que no están en su conocimiento entrenado
2. **Realizar acciones en sistemas externos** como actualizar bases de datos o enviar correos electrónicos
3. **Realizar cálculos complejos** que requieren software especializado
4. **Interactuar con el entorno físico** a través de dispositivos inteligentes
5. **Integrarse con sistemas empresariales** como ERPs, CRMs y otros sistemas de negocio

### Componentes del Patrón de Uso de Herramientas

1. **Agente Principal**: El componente que decide qué herramientas usar y cuándo usarlas
2. **Catalogo de Herramientas**: Colección de herramientas disponibles con metadatos
3. **Sistema de Invocación**: Mecanismo para llamar a herramientas de manera segura
4. **Procesador de Resultados**: Componente que interpreta y utiliza los resultados de las herramientas
5. **Middleware de Seguridad**: Capa que controla el acceso y aplicación de políticas de seguridad

### Implementación de Herramientas en el Marco Microsoft (MAF)

#### Definición de Herramientas Nativas

```python
from maf.tools import Tool, tool
from typing import Dict, Any
import requests
import json

class BusinessTools:
    """Colección de herramientas empresariales para agentes de IA"""
    
    @tool
    def get_sales_data(self, period: str, region: str = "all") -> Dict[str, Any]:
        """
        Obtiene datos de ventas para un periodo y región específicos.
        
        Args:
            period: Periodo temporal (ej., "last_month", "last_quarter", "year_to_date")
            region: Región específica (opcional, por defecto "all")
            
        Returns:
            Dict con datos de ventas, métricas clave y tendencias
        """
        # Simulación de llamada a sistema empresarial
        url = f"https://api.company.com/sales?period={period}&region={region}"
        headers = {"Authorization": "Bearer YOUR_TOKEN"}
        
        try:
            response = requests.get(url, headers=headers)
            if response.status_code == 200:
                sales_data = response.json()
                return {
                    "period": period,
                    "region": region,
                    "total_revenue": sales_data.get("total_revenue"),
                    "units_sold": sales_data.get("units_sold"),
                    "growth_rate": sales_data.get("growth_rate"),
                    "top_products": sales_data.get("top_products", [])[:5]
                }
            else:
                return {"error": f"Error al obtener datos de ventas: {response.status_code}"}
        except Exception as e:
            return {"error": f"Error al llamar a la herramienta: {str(e)}"}
    
    @tool
    def update_customer_record(self, customer_id: str, field: str, new_value: str) -> str:
        """
        Actualiza un campo específico del registro de un cliente.
        
        Args:
            customer_id: ID único del cliente
            field: Campo a actualizar (ej., "email", "address", "phone")
            new_value: Nuevo valor para el campo
            
        Returns:
            Mensaje de confirmación o error
        """
        # Validar campo permitido
        allowed_fields = ["email", "address", "phone", "preferences"]
        if field not in allowed_fields:
            return f"Campo no permitido. Campos válidos: {allowed_fields}"
        
        # Simulación de actualización en sistema empresarial
        url = f"https://api.company.com/customers/{customer_id}"
        headers = {"Authorization": "Bearer YOUR_TOKEN", "Content-Type": "application/json"}
        payload = {field: new_value}
        
        try:
            response = requests.put(url, headers=headers, json=payload)
            if response.status_code == 200:
                return f"Registro del cliente {customer_id} actualizado exitosamente. Campo: {field}, Valor: {new_value}"
            else:
                return f"Error al actualizar registro del cliente: {response.status_code}"
        except Exception as e:
            return f"Error al actualizar registro del cliente: {str(e)}"
    
    @tool
    def schedule_appointment(self, customer_id: str, service_type: str, preferred_time: str, consultant: str = None) -> Dict[str, Any]:
        """
        Programa una cita para un cliente con un tipo de servicio específico.
        
        Args:
            customer_id: ID del cliente
            service_type: Tipo de servicio (ej., "consultation", "demo", "support")
            preferred_time: Fecha y hora preferida en formato ISO 8601
            consultant: Consultor preferido (opcional)
            
        Returns:
            Dict con detalles de la cita programada
        """
        # Simulación de programación en sistema de citas
        import uuid
        appointment_id = f"APT-{str(uuid.uuid4())[:8].upper()}"
        
        appointment_data = {
            "appointment_id": appointment_id,
            "customer_id": customer_id,
            "service_type": service_type,
            "scheduled_time": preferred_time,
            "consultant": consultant if consultant else "auto_assigned",
            "status": "confirmed",
            "confirmation_sent": False
        }
        
        # Aquí iría la lógica real para guardar en el sistema de citas
        # Incluiría validación de disponibilidad, envío de confirmación, etc.
        
        return {
            "appointment_id": appointment_id,
            "status": "scheduled_simulation",  # No real scheduling in demo
            "details": appointment_data,
            "message": "Cita programada en simulación. En un sistema real, esta operación estaría sujeta a validación de disponibilidad y envío de confirmación."
        }

# Instanciar herramientas
business_tools = BusinessTools()
```

#### Herramientas Semánticas (Basadas en Prompts)

Además de las herramientas nativas en código, MAF también soporta herramientas semánticas basadas en prompts:

```python
from maf.tools import SemanticTool

# Ejemplo de herramienta semántica (conceptual)
semantic_sales_tool = SemanticTool(
    name="sales_insight_analyzer",
    description="Analiza datos de ventas y proporciona insights estratégicos",
    prompt_template="""
    Basándote en los siguientes datos de ventas para {period}:
    {sales_data}
    
    Proporciona un análisis que incluya:
    1. Tendencias clave identificadas
    2. Áreas de oportunidad
    3. Recomendaciones estratégicas
    4. Métricas comparativas
    """
)
```

### Integración de MCP (Model Context Protocol) con Herramientas

El Model Context Protocol (MCP) proporciona una capa estandarizada para la integración de herramientas que permite a los agentes descubrir y usar herramientas de manera segura y estandarizada.

```python
# Ejemplo de integración MCP con herramientas empresariales
from maf.mcp import MCPConnector
from maf.tools import MCPToolAdapter

class MCPEnterpriseTools:
    """Integración de herramientas empresariales usando MCP"""
    
    def __init__(self):
        self.mcp_connector = MCPConnector(server_url="https://mcp.enterprise.com")
    
    def create_tools_from_mcp_services(self):
        """Crea herramientas automáticamente desde servicios MCP disponibles"""
        available_services = self.mcp_connector.list_available_services()
        
        tools = []
        for service in available_services:
            tool_adapter = MCPToolAdapter(
                service_name=service.name,
                service_endpoint=service.endpoint,
                service_schema=service.input_schema
            )
            tools.append(tool_adapter)
        
        return tools
```

### Patrones de Integración de Herramientas

#### 1. Patrón de Descubrimiento Dinámico

Los agentes pueden descubrir herramientas disponibles en tiempo de ejecución:

```python
class ToolDiscoverer:
    """Sistema para descubrir herramientas disponibles dinámicamente"""
    
    def __init__(self, tool_catalog):
        self.tool_catalog = tool_catalog
    
    def discover_relevant_tools(self, task_description: str) -> list:
        """Descubre herramientas relevantes para una tarea específica"""
        # Analizar la descripción de la tarea para identificar palabras clave
        keywords = self._extract_keywords(task_description)
        
        # Filtrar herramientas basadas en palabras clave
        relevant_tools = []
        for tool in self.tool_catalog:
            if any(keyword in tool.description.lower() for keyword in keywords):
                relevant_tools.append(tool)
        
        return relevant_tools
    
    def _extract_keywords(self, text: str) -> list:
        """Extrae palabras clave del texto"""
        # Simplificado para el ejemplo
        keywords = ["sales", "customer", "appointment", "data", "report", "update"]
        found_keywords = [kw for kw in keywords if kw in text.lower()]
        return found_keywords
```

#### 2. Patrón de Invocación Secuencial

Para tareas que requieren una serie de llamadas a herramientas en orden específico:

```python
class SequentialToolInvoker:
    """Invoca herramientas en una secuencia específica"""
    
    def __init__(self, tool_registry):
        self.tool_registry = tool_registry
    
    async def execute_sequential_workflow(self, tool_sequence: list, initial_params: dict = None):
        """Ejecuta una secuencia de herramientas pasando resultados de una a otra"""
        params = initial_params or {}
        results = []
        
        for tool_spec in tool_sequence:
            tool_name = tool_spec["tool_name"]
            tool_params = tool_spec.get("params", {})
            
            # Fusionar parámetros pasados con los definidos en la secuencia
            merged_params = {**params, **tool_params}
            
            # Invocar herramienta
            tool = self.tool_registry.get_tool(tool_name)
            result = await tool.invoke(merged_params)
            
            # Guardar resultado
            results.append({
                "tool_name": tool_name,
                "input": merged_params,
                "output": result
            })
            
            # Actualizar parámetros para la siguiente herramienta
            params.update(result)
        
        return results
```

#### 3. Patrón de Invocación Paralela

Para tareas que pueden beneficiarse de la ejecución paralela de herramientas:

```python
import asyncio

class ParallelToolInvoker:
    """Invoca múltiples herramientas en paralelo"""
    
    def __init__(self, tool_registry):
        self.tool_registry = tool_registry
    
    async def execute_parallel_tools(self, tool_specs: list):
        """Ejecuta múltiples herramientas en paralelo"""
        async def invoke_tool(tool_spec):
            tool_name = tool_spec["tool_name"]
            params = tool_spec.get("params", {})
            
            tool = self.tool_registry.get_tool(tool_name)
            result = await tool.invoke(params)
            
            return {
                "tool_name": tool_name,
                "input": params,
                "output": result
            }
        
        # Ejecutar todas las herramientas en paralelo
        tasks = [invoke_tool(spec) for spec in tool_specs]
        results = await asyncio.gather(*tasks)
        
        return results
```

### Buenas Prácticas para el Uso de Herramientas

#### 1. Seguridad y Validación de Entradas

Siempre valida las entradas antes de pasarlas a herramientas externas:

```python
import re

def validate_tool_inputs(params: dict, expected_types: dict, allowed_values: dict = None):
    """Valida entradas de herramientas para seguridad"""
    for param_name, expected_type in expected_types.items():
        if param_name in params:
            value = params[param_name]
            
            # Verificar tipo
            if not isinstance(value, expected_type):
                raise ValueError(f"Parameter {param_name} must be of type {expected_type.__name__}")
            
            # Validar formato si es string
            if expected_type == str:
                # Prevenir inyección de comandos o SQL
                if re.search(r'[;\'"\\]', value):
                    raise ValueError(f"Parameter {param_name} contains invalid characters")
            
            # Validar valores permitidos
            if allowed_values and param_name in allowed_values:
                if value not in allowed_values[param_name]:
                    raise ValueError(f"Parameter {param_name} has invalid value: {value}")
    
    return True
```

#### 2. Control de Acceso y Autorización

Implementar capas de autorización para herramientas sensibles:

```python
from enum import Enum

class ToolAccessLevel(Enum):
    READ_ONLY = "read_only"
    READ_WRITE = "read_write"
    ADMIN = "admin"

class ToolPermissionManager:
    """Gestiona permisos y acceso a herramientas"""
    
    def __init__(self):
        self.tool_permissions = {
            "get_sales_data": [ToolAccessLevel.READ_ONLY, ToolAccessLevel.READ_WRITE, ToolAccessLevel.ADMIN],
            "update_customer_record": [ToolAccessLevel.READ_WRITE, ToolAccessLevel.ADMIN],
            "schedule_appointment": [ToolAccessLevel.READ_WRITE, ToolAccessLevel.ADMIN]
        }
    
    def check_access(self, agent_role: str, tool_name: str) -> bool:
        """Verifica si un agente puede usar una herramienta específica"""
        if tool_name not in self.tool_permissions:
            return False
        
        required_levels = self.tool_permissions[tool_name]
        agent_level = ToolAccessLevel(agent_role.upper().replace(" ", "_"))
        
        return agent_level in required_levels
```

#### 3. Manejo de Errores y Resiliencia

Implementa estrategias de manejo de errores robustas:

```python
import time
from typing import Optional

class ToolInvokerWithResilience:
    """Invocador de herramientas con manejo de errores y reintentos"""
    
    def __init__(self, max_retries: int = 3, backoff_factor: float = 1.0):
        self.max_retries = max_retries
        self.backoff_factor = backoff_factor
    
    async def invoke_with_retry(self, tool, params: dict) -> dict:
        """Invoca herramienta con lógica de reintento"""
        last_exception = None
        
        for attempt in range(self.max_retries):
            try:
                result = await tool.invoke(params)
                return result
            except Exception as e:
                last_exception = e
                
                if attempt < self.max_retries - 1:
                    # Espera exponencial antes del reintento
                    wait_time = self.backoff_factor * (2 ** attempt)
                    await asyncio.sleep(wait_time)
                else:
                    # Todos los reintentos fallaron
                    pass
        
        # Todos los reintentos fallaron
        return {"error": f"All retries failed. Last error: {str(last_exception)}"}
```

### Ejemplos Profesionales Recientes (2025)

#### Ejemplo 1: Sistema de Soporte Técnico en Cisco
Cisco implementó un sistema de soporte técnico basado en agentes con uso extensivo de herramientas:
- **Patrón de Descubrimiento Dinámico**: Agentes que identifican herramientas apropiadas según el problema
- **Patrón de Invocación Secuencial**: Diagnóstico automatizado que llama a múltiples herramientas en orden
- **Control de Acceso**: Middleware de autorización para herramientas sensibles de red
- **Resultado**: Reducción del 45% en el tiempo de resolución de problemas, mejora del 40% en la precisión de diagnósticos

#### Ejemplo 2: Plataforma de Investigación Financiera en Bloomberg
Bloomberg desarrolló una plataforma de investigación financiera con agentes:
- **Patrón de Invocación Paralela**: Consulta simultánea a múltiples fuentes de datos financieros
- **Validación de Seguridad**: Control de entrada para prevenir inyecciones maliciosas
- **Resiliencia de Herramientas**: Sistemas de reintento para fuentes de datos intermitentes
- **Resultado**: Tiempo de análisis reducido del 4-6 horas a 30 minutos, precisión mejorada en más del 50%

#### Ejemplo 3: Sistema de Gestión de Recursos Humanos en SAP
SAP creó un asistente de recursos humanos con herramientas empresariales:
- **Integración MCP**: Conexión estandarizada con sistemas de nómina y beneficios
- **Validación de Entradas**: Control de seguridad para datos sensibles de empleados
- **Patrón de Memoria Distribuida**: Compartir contexto entre diferentes herramientas de RRHH
- **Resultado**: 60% más rápido en la resolución de consultas de empleados, reducción del 50% en errores administrativos

#### Ejemplo 4: Plataforma de Gestión de Contenido en Adobe
Adobe implementó un sistema de gestión de contenido con agentes de IA:
- **Patrón de Secuencia de Herramientas**: Automatización de flujo de trabajo de contenido (ingesta, procesamiento, publicación)
- **Control de Acceso**: Niveles diferentes para herramientas según rol del usuario
- **Middleware de Seguridad**: Filtrado de contenido y control de derechos
- **Resultado**: Aumento del 150% en eficiencia de gestión de activos, mejora del 70% en cumplimiento de derechos de autor

#### Ejemplo 5: Sistema de Seguimiento de Envíos en UPS
UPS desarrolló un sistema de seguimiento basado en agentes:
- **Invocación Paralela**: Consulta múltiple a bases de datos de envíos, rutas y estado
- **Manejo de Errores**: Sistemas robustos para manejar bases de datos intermitentes
- **Patrón de Descubrimiento**: Herramientas que se adaptan a diferentes tipos de envíos y sistemas
- **Resultado**: Tiempo de respuesta reducido en un 80%, mejora del 45% en precisión de estimaciones de entrega

### Consideraciones de Producción

#### Rendimiento
- **Caching**: Almacenamiento en caché de resultados de herramientas costosas
- **Rate Limiting**: Control de frecuencia de llamadas a herramientas externas
- **Optimización de Secuencias**: Minimizar el número de llamadas necesarias

#### Seguridad
- **Validación de Entradas**: Verificar todos los parámetros antes de usar herramientas
- **Control de Acceso**: Middleware para restringir acceso a herramientas sensibles
- **Auditoría**: Registro completo de todas las invocaciones de herramientas
- **Sanitización de Salidas**: Filtrar resultados sensibles antes de mostrarlos

#### Mantenibilidad
- **Documentación de Herramientas**: Especificación clara de entradas, salidas y propósito
- **Pruebas Unitarias**: Pruebas para cada herramienta para verificar funcionalidad
- **Versionado**: Control de versiones para herramientas que cambian con el tiempo
- **Monitoreo**: Observabilidad de errores, rendimiento y uso de herramientas

### Tendencias Futuras en el Uso de Herramientas (2025-2026)

- **Herramientas Auto-Generadas**: Agentes que crean sus propias herramientas según necesidad
- **Integración Semántica Avanzada**: Herramientas que comprenden mejor el contexto de su uso
- **Seguridad por Defecto**: Controles de seguridad integrados en el registro de herramientas
- **Detección de Anomalías**: Sistemas que identifican uso inusual o potencialmente malicioso de herramientas

### Próxima Lección

En la próxima lección, exploraremos el patrón Agentic RAG (Retrieval-Augmented Generation), que combina la capacidad de recuperación de información con la generación de contenido para crear agentes más inteligentes y contextuales.