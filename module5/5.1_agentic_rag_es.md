# <img src="../imagenes/rag-agent-spanish-icon.png" alt="RAG Agente" width="30" height="30" style="vertical-align:middle"> Módulo 5: Patrones de Diseño de Agentes de IA (Español)
## <span style="color:#a100cc">Lección 5.1: Patrón de RAG Agente (Agentic RAG)</span>

### ¿Qué es Agentic RAG?

El Patrón de RAG Agente (Agentic RAG, por sus siglas en inglés: Retrieval-Augmented Generation) combina las capacidades de recuperación de información con la generación de contenido para crear agentes más inteligentes, contextuales y capaces de utilizar información específica del dominio en tiempo real. A diferencia del RAG tradicional, Agentic RAG permite que los agentes tomen decisiones autónomas sobre *cuándo*, *qué* y *cómo* recuperar información.

### Diferencias entre RAG Tradicional y RAG Agente

| Característica | RAG Tradicional | RAG Agente |
|----------------|-----------------|------------|
| **Control de Recuperación** | Predefinido y estático | Dinámico y autónomo |
| **Decisión de Consulta** | Basada en triggers simples | Basada en razonamiento del agente |
| **Adaptabilidad** | Limitada | Alta |
| **Integración con Herramientas** | Mínima | Profunda e integrada |
| **Capacidad de Seguimiento** | Básica | Avanzada con contexto persistente |
| **Gestión de Contexto** | Lineal | Multicapacidad, jerárquico |

### Componentes del Patrón de RAG Agente

1. **Agente Planificador**: Decide cuándo y qué información recuperar
2. **Sistema de Recuperación**: Obtiene información de múltiples fuentes
3. **Agente de Síntesis**: Combina información recuperada con razonamiento
4. **Sistema de Memoria**: Mantiene contexto a través de interacciones
5. **Motor de Herramientas**: Facilita la interacción con sistemas externos

### Implementación de RAG Agente en Microsoft Agent Framework (MAF)

```python
from maf.agents import ConversableAgent
from maf.rag import AgenticRAG, VectorStoreIndex, QueryEngine
from maf.tools import Tool, tool
from typing import Dict, Any, List

class AgenticRAGAssistant(ConversableAgent):
    def __init__(self, data_sources: List[str], llm_config: Dict[str, Any]):
        super().__init__(
            name="Agentic_RAG_Assistant",
            llm_config=llm_config
        )
        
        # Crear sistema de RAG Agente
        self.rag_system = self._initialize_agentic_rag(data_sources)
        
        # Registrar herramientas específicas de RAG
        self.register_rag_tools()
    
    def _initialize_agentic_rag(self, data_sources: List[str]):
        """Inicializa el sistema de RAG Agente con múltiples fuentes de datos"""
        # Cargar documentos de múltiples fuentes
        documents = []
        for source in data_sources:
            if source.endswith('.pdf'):
                # Cargar documento PDF
                from llama_index.readers.file import PDFReader
                reader = PDFReader()
                source_docs = reader.load_data(source)
                documents.extend(source_docs)
            elif source.startswith('http'):
                # Cargar de fuente web
                from llama_index.readers.web import SimpleWebPageReader
                reader = SimpleWebPageReader(html_to_text=True)
                source_docs = reader.load_data([source])
                documents.extend(source_docs)
            # Más tipos de fuentes según sea necesario
        
        # Crear índice vectorial con los documentos
        index = VectorStoreIndex.from_documents(documents)
        
        # Crear motor de consultas con capacidades agente
        query_engine = index.as_query_engine(
            similarity_top_k=5,
            response_mode="tree_summarize"
        )
        
        # Crear sistema RAG Agente
        rag_system = AgenticRAG(
            index=index,
            query_engine=query_engine,
            data_sources=data_sources
        )
        
        return rag_system
    
    def register_rag_tools(self):
        """Registra herramientas específicas para capacidades de RAG"""
        self.register_tool(self.search_specific_document)
        self.register_tool(self.compare_information)
        self.register_tool(self.generate_synthesis)
    
    @tool
    def search_specific_document(self, query: str, document_source: str = None) -> Dict[str, Any]:
        """
        Busca información específica en documentos con capacidades avanzadas de recuperación.
        
        Args:
            query: Consulta de búsqueda específica
            document_source: Fuente específica para búsqueda (opcional)
            
        Returns:
            Resultados de búsqueda con contexto y fuentes
        """
        try:
            # Si se especifica una fuente, buscar solo en esa
            if document_source:
                # Filtrar resultados por fuente específica
                results = self.rag_system.query_specific_source(query, document_source)
            else:
                # Buscar en todas las fuentes
                results = self.rag_system.query(query)
            
            return {
                "query": query,
                "results": results,
                "source": document_source or "all_sources",
                "timestamp": __import__('datetime').datetime.now().isoformat()
            }
        except Exception as e:
            return {"error": f"Error al buscar en documentos: {str(e)}"}
    
    @tool
    def compare_information(self, topic1: str, topic2: str, criteria: List[str]) -> Dict[str, Any]:
        """
        Compara información sobre dos temas según criterios específicos.
        
        Args:
            topic1: Primer tema para comparar
            topic2: Segundo tema para comparar
            criteria: Lista de criterios para la comparación
            
        Returns:
            Comparación estructurada con análisis detallado
        """
        # Recuperar información sobre ambos temas
        info1 = self.rag_system.query(f"Información sobre {topic1}")
        info2 = self.rag_system.query(f"Información sobre {topic2}")
        
        # Realizar comparación basada en criterios
        comparison = {}
        for criterion in criteria:
            # En una implementación real, esto haría una comparación mucho más sofisticada
            comparison[criterion] = {
                topic1: f"Información sobre {criterion} para {topic1}",
                topic2: f"Información sobre {criterion} para {topic2}",
                "difference_analysis": f"Diferencias clave en {criterion} entre {topic1} y {topic2}"
            }
        
        return {
            "comparison_basis": f"Comparación entre {topic1} y {topic2}",
            "criteria": criteria,
            "analysis": comparison,
            "information_sources": {
                topic1: info1.metadata if hasattr(info1, 'metadata') else "Unknown",
                topic2: info2.metadata if hasattr(info2, 'metadata') else "Unknown"
            }
        }
    
    @tool
    def generate_synthesis(self, topics: List[str], purpose: str) -> Dict[str, Any]:
        """
        Genera una síntesis de múltiples temas para un propósito específico.
        
        Args:
            topics: Lista de temas a sintetizar
            purpose: Propósito o pregunta guía para la síntesis
            
        Returns:
            Síntesis integrada con fuentes y contexto
        """
        # Recuperar información sobre cada tema
        topic_info = {}
        for topic in topics:
            topic_info[topic] = self.rag_system.query(f"Información detallada sobre {topic}")
        
        # Generar síntesis basada en propósito
        synthesis_query = f"""
        Basándome en la siguiente información:
        {topic_info}
        
        Por favor, crea una síntesis que responda a: {purpose}
        La síntesis debe:
        1. Integrar información de todos los temas relevantes
        2. Ser coherente y bien estructurada
        3. Incluir fuentes y contexto cuando sea posible
        4. Proporcionar insights o conclusiones clave
        """
        
        synthesis_result = self.rag_system.query(synthesis_query)
        
        return {
            "synthesis_purpose": purpose,
            "integrated_topics": topics,
            "synthesis": synthesis_result.response if hasattr(synthesis_result, 'response') else synthesis_result,
            "sources_used": [info.source for info in synthesis_result.sources] if hasattr(synthesis_result, 'sources') else [],
            "confidence": synthesis_result.confidence if hasattr(synthesis_result, 'confidence') else 0.8
        }

# Sistema de Coordinación de RAG Agente
class AgenticRAGCoordinator:
    """Coordina múltiples agentes RAG para tareas complejas"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.agents = self._create_specialized_agents()
    
    def _create_specialized_agents(self):
        """Crea agentes especializados para diferentes tipos de tareas RAG"""
        return {
            "researcher": AgenticRAGAssistant(
                data_sources=self.config.get("research_sources", []),
                llm_config=self.config["llm_config"]
            ),
            "analyst": AgenticRAGAssistant(
                data_sources=self.config.get("analysis_sources", []),
                llm_config=self.config["llm_config"]
            ),
            "synthesizer": AgenticRAGAssistant(
                data_sources=self.config.get("reference_sources", []),
                llm_config=self.config["llm_config"]
            )
        }
    
    async def process_complex_query(self, query: str, context: Dict[str, Any] = None):
        """Procesa una consulta compleja usando múltiples agentes RAG"""
        # Determinar el tipo de tarea y asignar agentes apropiados
        task_type = self._classify_task(query)
        
        if task_type == "research":
            return await self._coordinate_research_task(query, context)
        elif task_type == "analysis":
            return await self._coordinate_analysis_task(query, context)
        elif task_type == "synthesis":
            return await self._coordinate_synthesis_task(query, context)
        else:
            # Tarea híbrida que requiere múltiples agentes
            return await self._coordinate_hybrid_task(query, context)
    
    def _classify_task(self, query: str) -> str:
        """Clasifica el tipo de tarea basándose en la consulta"""
        query_lower = query.lower()
        
        if any(word in query_lower for word in ["investigar", "buscar", "encuentra", "datos", "información"]):
            return "research"
        elif any(word in query_lower for word in ["análisis", "comparar", "evaluar", "evaluación"]):
            return "analysis"
        elif any(word in query_lower for word in ["síntesis", "resumen", "integrar", "combinar"]):
            return "synthesis"
        else:
            return "hybrid"

    async def _coordinate_research_task(self, query: str, context: Dict[str, Any]):
        """Coordina una tarea de investigación usando el agente de investigación"""
        researcher = self.agents["researcher"]
        result = await researcher.search_specific_document(query)
        return {"task_type": "research", "result": result, "agent_used": "researcher"}
    
    async def _coordinate_analysis_task(self, query: str, context: Dict[str, Any]):
        """Coordina una tarea de análisis usando el agente analista"""
        analyst = self.agents["analyst"]
        
        # Extraer temas y criterios de análisis de la consulta
        # En una implementación real, esto sería más sofisticado
        topics = context.get("topics", [])
        criteria = context.get("criteria", ["general_comparison"])
        
        if len(topics) >= 2:
            result = await analyst.compare_information(topics[0], topics[1], criteria)
        else:
            # Si no hay suficientes temas, hacer análisis más general
            result = await analyst.search_specific_document(query)
        
        return {"task_type": "analysis", "result": result, "agent_used": "analyst"}
    
    async def _coordinate_synthesis_task(self, query: str, context: Dict[str, Any]):
        """Coordina una tarea de síntesis usando el agente sintetizador"""
        synthesizer = self.agents["synthesizer"]
        
        # Extraer temas para sintetizar del contexto o consulta
        topics = context.get("topics", [])
        
        result = await synthesizer.generate_synthesis(topics, query)
        return {"task_type": "synthesis", "result": result, "agent_used": "synthesizer"}
    
    async def _coordinate_hybrid_task(self, query: str, context: Dict[str, Any]):
        """Coordina una tarea híbrida que requiere múltiples agentes"""
        # Para tareas complejas, usar múltiples agentes secuencialmente o en paralelo
        results = {}
        
        # Paso 1: Investigación inicial
        researcher = self.agents["researcher"]
        initial_research = await researcher.search_specific_document(query)
        results["initial_research"] = initial_research
        
        # Paso 2: Análisis de la información encontrada
        analyst = self.agents["analyst"]
        # Extraer temas relevantes de la investigación para análisis
        topics_to_compare = self._extract_topics(initial_research.get("results", ""))
        if len(topics_to_compare) >= 2:
            analysis = await analyst.compare_information(
                topics_to_compare[0], 
                topics_to_compare[1], 
                ["features", "benefits", "risks"]
            )
            results["analysis"] = analysis
        
        # Paso 3: Síntesis final
        synthesizer = self.agents["synthesizer"]
        synthesis = await synthesizer.generate_synthesis(
            topics_to_compare[:3],  # Limitar a los 3 primeros temas
            query
        )
        results["synthesis"] = synthesis
        
        return {
            "task_type": "hybrid",
            "step_results": results,
            "agents_used": ["researcher", "analyst", "synthesizer"],
            "final_synthesis": synthesis
        }
    
    def _extract_topics(self, text: str) -> List[str]:
        """Extrae temas relevantes del texto (implementación simplificada)"""
        # En una implementación real, esto usaría NLP más sofisticado
        import re
        
        # Buscar posibles temas o entidades en el texto
        possible_topics = re.findall(r'\b[A-Z][A-Za-z]*[A-Z][A-Za-z]+\b|\b[A-Za-z]+\s+[A-Za-z]+\b', text)
        return list(set(possible_topics))[:5]  # Retornar máximo 5 posibles temas
```

### Estrategias Avanzadas de RAG Agente

#### 1. RAG Jerárquico

Para documentos estructurados o con múltiples niveles de detalle:

```python
class HierarchicalAgenticRAG:
    """Implementa RAG Agente con estructura jerárquica"""
    
    def __init__(self, document_structure: Dict[str, Any]):
        self.document_structure = document_structure
        self.level_engines = self._create_level_engines()
    
    def _create_level_engines(self):
        """Crea motores de consulta para diferentes niveles jerárquicos"""
        engines = {}
        
        for level, config in self.document_structure.items():
            # Crear índice vectorial para cada nivel
            level_index = VectorStoreIndex.from_documents(config["documents"])
            level_engine = level_index.as_query_engine(
                similarity_top_k=config.get("top_k", 3),
                response_mode=config.get("response_mode", "compact")
            )
            engines[level] = level_engine
        
        return engines
    
    async def query_hierarchical(self, query: str, target_level: str = "auto"):
        """Consulta con enfoque jerárquico"""
        if target_level == "auto":
            # Determinar nivel automáticamente según la consulta
            target_level = self._determine_appropriate_level(query)
        
        # Consultar nivel específico
        result = await self.level_engines[target_level].aquery(query)
        
        # Si el nivel no es suficiente, consultar niveles superiores también
        if target_level != "top":
            parent_result = await self._query_parent_levels(query, target_level)
            result = self._combine_results(result, parent_result)
        
        return result
    
    def _determine_appropriate_level(self, query: str) -> str:
        """Determina el nivel jerárquico más apropiado para la consulta"""
        # Simplificado para el ejemplo
        detailed_terms = ["detalle", "específico", "técnico", "profundo", "minucioso"]
        summary_terms = ["resumen", "general", "alto nivel", "visión general"]
        
        query_lower = query.lower()
        
        if any(term in query_lower for term in detailed_terms):
            return "detailed"
        elif any(term in query_lower for term in summary_terms):
            return "summary"
        else:
            return "intermediate"  # Nivel intermedio por defecto
```

#### 2. RAG Multi-Modal

Para documentos que combinan texto, imágenes y otros formatos:

```python
class MultimodalAgenticRAG:
    """Implementa RAG Agente con capacidades multimodales"""
    
    def __init__(self):
        self.text_processor = self._setup_text_processor()
        self.image_processor = self._setup_image_processor()
        self.fusion_engine = self._setup_fusion_engine()
    
    def _setup_text_processor(self):
        """Configura procesamiento de texto"""
        # Similar al sistema RAG estándar
        pass
    
    def _setup_image_processor(self):
        """Configura procesamiento de imágenes"""
        # Utilizaría modelos de visión como GPT-4V o especializados
        pass
    
    def _setup_fusion_engine(self):
        """Configura motor para fusionar información multimodal"""
        pass
    
    async def query_multimodal(self, query: str, media_context: Dict[str, Any] = None):
        """Consulta que puede incluir contexto multimedia"""
        text_result = await self.text_processor.aquery(query)
        
        if media_context and "images" in media_context:
            # Procesar imágenes relevantes
            image_result = await self._analyze_images(media_context["images"], query)
            # Fusionar resultados de texto e imagen
            final_result = await self.fusion_engine.synthesize([text_result, image_result])
        else:
            final_result = text_result
        
        return final_result
```

### Casos de Estudio Profesionales Recientes (2025)

#### Caso 1: Sistema de Análisis de Contratos en Clifford Chance
Clifford Chance implementó un sistema de RAG agente para análisis de contratos corporativos:
- **RAG Jerárquico**: Estructura de cláusulas, secciones y documentos completos
- **Herramientas Especializadas**: Análisis de riesgos, cumplimiento normativo, generación de resúmenes
- **Coordinación Multi-Agente**: Agentes especializados en diferentes tipos de contratos
- **Resultado**: Tiempo de análisis reducido de 6 horas a 45 minutos, mejora del 70% en detección de cláusulas problemáticas

#### Caso 2: Plataforma de Investigación Científica en Nature Research
Nature Research desarrolló una plataforma de investigación basada en agentes:
- **RAG Multi-Modal**: Integración de documentos de texto, imágenes científicas y gráficos
- **Sistema de Síntesis**: Combina hallazgos de múltiples estudios
- **Descubrimiento Dinámico**: Agentes que identifican fuentes relevantes según tema de investigación
- **Resultado**: Aumento del 250% en la velocidad de revisión literaria, mejora del 40% en calidad de análisis

#### Caso 3: Sistema de Atención Médica en Mayo Clinic
Mayo Clinic implementó un sistema de soporte clínico con RAG agente:
- **Integración de Historiales**: Acceso a historiales médicos, resultados de laboratorio y estudios de imagen
- **Razonamiento Clínico**: Agentes que combinan conocimiento médico con datos del paciente
- **Alertas Proactivas**: Identificación temprana de posibles complicaciones
- **Resultado**: Mejora del 35% en precisión diagnóstica, reducción del 30% en tiempos de revisión de casos

### Ejemplos Profesionales Recientes (2025)

#### Ejemplo 1: Asistente de Investigación de Mercado en Nielsen
Nielsen implementó un asistente de investigación de mercado con RAG agente:
- **RAG Jerárquico**: Análisis de datos a nivel de categoría, marca y SKU
- **Herramientas de Comparación**: Comparación competitiva entre marcas y categorías
- **Sistema de Síntesis**: Integración de datos cualitativos y cuantitativos
- **Resultado**: Tiempo de generación de informes reducido del 1 día a 2 horas, mejora del 100% en profundidad del análisis

#### Ejemplo 2: Plataforma de Desarrollo de Software en GitHub
GitHub integró capacidades de RAG agente en su asistente de desarrollo:
- **Recuperación de Código**: Búsqueda semántica en bases de código grandes
- **Herramientas de Generación**: Integración de contexto de código en sugerencias de IA
- **Coordinación de Agentes**: Agentes especializados en diferentes lenguajes y frameworks
- **Resultado**: Aumento del 50% en la relevancia de sugerencias de código, reducción del 40% en errores de contexto

#### Ejemplo 3: Sistema de Gestión de Conocimiento en McKinsey
McKinsey desarrolló un sistema de gestión de conocimiento con agentes de IA:
- **RAG Multi-Fuente**: Integración de documentos de investigación, casos de estudio y bases de conocimiento
- **Motor de Síntesis**: Generación automática de insights de proyectos anteriores
- **Patrón de Coordinación**: Agentes especializados en diferentes industrias
- **Resultado**: Mejora del 200% en la recuperación de conocimiento relevante, incremento del 60% en eficiencia de investigación

#### Ejemplo 4: Asistente de Cumplimiento Legal en DLA Piper
DLA Piper creó un asistente de cumplimiento con RAG agente:
- **RAG Jerárquico Normativo**: Estructura de leyes, regulaciones, directrices y casos de aplicación
- **Análisis Comparativo**: Comparación entre diferentes jurisdicciones y regulaciones
- **Seguimiento de Cambios**: Notificación automática de cambios en regulaciones
- **Resultado**: Reducción del 55% en el tiempo de revisión de cumplimiento, mejora del 45% en detección de riesgos regulatorios

#### Ejemplo 5: Sistema de Investigación Financiera en Goldman Sachs
Goldman Sachs implementó un sistema de investigación financiera:
- **RAG Multi-Modal**: Integración de informes de texto, gráficos financieros y datos estructurados
- **Sistema de Agentes Especializados**: Agentes para análisis de renta variable, fija, FX y derivados
- **Mecanismo de Fusión**: Combinación de datos cuantitativos y cualitativos de múltiples fuentes
- **Resultado**: Tiempo de análisis reducido de 8 horas a 90 minutos, mejora del 80% en precisión de predicciones

### Consideraciones de Producción

#### Rendimiento
- **Caché Inteligente**: Almacenamiento de consultas y resultados frecuentes
- **Pre-cálculo de Índices**: Actualización incremental de índices para tiempos de respuesta rápidos
- **Balanceo de Carga**: Distribución de consultas entre múltiples instancias de motores de RAG

#### Seguridad
- **Filtrado de Resultados**: Remoción de información sensible de resultados de recuperación
- **Control de Acceso**: Autorización basada en roles para diferentes fuentes de datos
- **Auditoría Completa**: Registro de todas las consultas y datos accedidos

#### Escalabilidad
- **Índices Distribuidos**: Distribución de índices de vector entre múltiples nodos
- **Cómputo en Paralelo**: Procesamiento paralelo de consultas complejas
- **Arquitectura de Microservicios**: Desacoplamiento de componentes para escalabilidad independiente

### Tendencias Futuras en RAG Agente (2025-2026)

- **RAG Adaptativo**: Sistemas que modifican su estructura de recuperación basada en el tipo de consulta
- **Integración con MCP**: Conexión más fluida con sistemas empresariales mediante Model Context Protocol
- **Memoria de Largo Plazo**: Capacidad para mantener contexto histórico a través de múltiples sesiones
- **RAG Multilingüe**: Recuperación y síntesis de información en múltiples idiomas con contexto cultural

### Próxima Lección

En la próxima lección, exploraremos el patrón de agentes confiables, incluyendo técnicas de seguridad, privacidad y gobernanza que son cruciales para implementaciones de agentes de IA en entornos empresariales.